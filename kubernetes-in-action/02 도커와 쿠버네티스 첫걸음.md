# 2. 도커와 쿠버네티스 첫걸음

## 2.1  도커를 사용한 컨테이너 이미지 생성, 실행, 공유하기

### 2.1.1 도커 설치와 Hello World 컨테이너 실행하기

- 리눅스 머신에 도커를 설치해야 한다. 도커를 설치하면 가상머신이 생성되고, 가상머신 안에 도커 데몬이 구동된다. 호스트 OS에서 도커 클라이언트 실행파일을 사용하면 가상머신에 구동된 도커 데몬과 통신한다.
- $ docker run busybox echo “Hello World” 또는 $ docer run <image>:<tag> 를 실행한다면?
    1. 도커는 busybox :latest 이미지가 로컬 컴퓨터에 존재하는지 체크한다.
    2. 존재하지 않는다면 도커는 [http://docker.io](http://docker.io) 의 도커 허브 레지스트리에서 이미지를 다운로드한다.
    3. 컴퓨터에 이미지의 다운로드가 완료되면 도커는 이미지로부터 격리된 컨테이너를 생성하고 컨테이너 내부에서 명령어를 실행한다.
    4. echo 명령어는 텍스트를 표준 출력(STDOUT)으로 출력한 후 프로세스를 중단하고 컨테이너도 중지된다.
    - 실행되어야 할 명령어는 보통 이미지를 생성할 때 내부에 넣어 패키징하며, 원하는 경우 이 명령어를 오버라이딩할 수 있다!
    - 이미지와 이름에 여러 개의 버전을 가질 수 있고, 태그를 가져야 한다. 이미지를 참조할 때 명시적으로 태그를 지정하지 않으면, 도커는 latest 태그를 참조한 것으로 간주한다.
    

### 2.1.2 간단한 node.js 애플리케이션 생성하기
- 여느 프로세스와 마찬가지로 호스트 머신에서 실행되고 있음에도 호스트 머신의 호스트 이름을 바라보는 것이 아니라 애플리케이션이 실행 중인 컨테이너 내부의 호스트 이름을 바라본다. 
- 이런 동작 방식이 쿠버네티스 위에 애플리케이션을 배포하고 스케일 아웃(수평 확장을 통해 다수의 애플리케이션 인스턴스를 기동)을 할 때 유용하게 사용된다.

### 2.1.3 이미지를 위한 Dockefile 생성
- Dockerfile 에는 도커가 이미지를 생성하기 위해 수행해야 할 지시 사항이 담겨 있다.
```docker
# dockerfile 생성
FROM node:7      #시작점(이미지 생성의 기반이 되는 기본 이미지)로 사용할 컨테이너 이미지 
ADD app.js /app.js  #해당 파일을 이미지의 루트 디렉터리에 동일 이름으로 추가
ENTRYPOINT ["node", "app.js"] #이미지를 실행했을 때 수행돼야 할 명령어를 정의
```

```bash
# 컨테이너 이미지 생성
$ docker build -t kubia .
# 도커에게 현재 디렉터리의 컨텐츠를 기반으로 kubia 라고 부르는 이미지를 빌드하라고 요청했다
# . 이 현재 디렉터리
```
- 도커는 디렉터리 내 Dockerfile 을 살펴보고 파일에 명시된 지시 사항에 근거해 이미지를 빌드한다.

### 2.1.4 어떻게 이미지가 빌드가 되는지?
- 빌드 프로세스는 도커 클라이언트가 수행하지 않는다. 디렉터리의 전체 콘텐츠가 도커 데몬에 업로드되고 그곳에서 이미지가 빌드된다. 도커 클라이언트(예로 호스트 OS)와 데몬(예로 가상머신 내부)은 같은 머신에 있을 필요는 없다.
- 팁! 빌드 디렉터리에 불필요한 파일을 포함시키지 마라. 특히 원격 머신에 도커 데몬이 위치한 경우 이러한 파일이 빌드 프로세스의 속도 저하를 가져온다.
- 이미지 레이어에 관해 이해하기
    - 이미지는 여러 개의 레이어로 구성된다. 서로 다른 이미지가 여러 개의 레이어를 공유할 수 있기 때문에 이미지의 저장과 전송에 효과적이다. 저장되지 않은 레이어만 다운로드할 수 있다.
    - Dockerfile 빌드 시
        1. 이미지를 빌드하는 동안 기본 이미지의 모든 레이어를 가져온다
        2. 도커는 그 위에 새로운 레이어를 생성하고 (우리가 추가한)app.js 파일을 그 위에 추가한다
        3. 이미지가 실행할 때 수행돼야 할 명령을 지정하는 또 하나의 레이어를 추가한다. 이 마지막 레이어는 kubia(우리가 지정한):latest 라고 태그를 지정한다.
        4. 이미지 빌드 프로세스가 완료되면 docker images 로 확인할 수 있다.
        - 책에서 사진 참고하기!
- Dockerfile을 이용한 이미지 빌드와 수동 빌드 비교하기
    - 기존 이미지에서 컨테이너를 실행하고 컨테이너 내부에서 명령어를 수행한 후 빠져나와 최종 상태를 새로운 이미지로 커밋하는 방법으로 이미지를 수동 생성할 수도 있다. 하지만, Dockerfile을 이용하는 것이 훨씬 반복 가능하고 이미지 빌드를 자동화할 수 있는 방법이다.

### 2.1.5 컨테이너 이미지 실행
```bash
$ docker run --name kubia-container -p 8080:8080 -d kubia
```
- 도커가 kubia 이미지에서 kubia-container라는 새로운 이름의 컨테이너를 실행한다.
- -d는 백그라운드에서 실행되며 로컬 머신의 포트와 컨테이너 내부 포트를 매핑했다.
- 애플리케이션 접근하기
    - curl localhost:8080
- 실행 중인 모든 컨테이너 조회하기
    - docker ps
- 컨테이너에 관한 추가 정보 얻기
    - docker inspect kubia-container

### 2.1.6 실행 중인 컨테이너 내부 탐색하기
- 실행 중인 컨테이너 내부에서 셀 실행하기
    - $ docker exec -it kubia-container bash
        - kubia-container 내부에 bash를 실행한다.
        - bash 프로세스는 컨테이너의 메인 프로세스와 동일한 리눅스 네임스페이스를 갖는다. 따라서 컨테이너 내부를 탐색할 수 있고, Node.js와 애플리케이션이 시스템을 보는 방법을 알 수 있다
        - -i : 표준 입력(STDIN)을 오픈 상태로 유지한다. 셸에 명령어를 입력하기 위해 필요하다.
        - -t : 의사(pesudo) 터미널(TTY)을 할당한다.
- 내부에서 컨테이너 탐색
    - $ ps aux
    - 단 세 개의 프로세스만 볼 수 있고 호스트 운영체제의 다른 프로세스는 볼 수가 없다.
- 호스트 운영체제에서 실행 중인 컨테이너에서 실행되는 프로세스 이해하기
    - 호스트 운영체제의 프로세스를 조회해보면 모든 프로세스를 조회할 수 있다.
    - 맥 또는 윈도우는 도커 데몬이 실행 중인 가상머신에 로그인해야 프로세스를 볼 수 있다.
    - $ ps aux | grep app.js
- 호스트와 컨테이너의 프로세스 ID가 다르다는 점을 확인할 수 있다. 컨테이너는 자체 리눅스 PID 네임스페이스를 사용하며 고유의 시퀀스 번호를 가지고 완전히 분리된 프로세스 트리를 갖고 있다.
- 격리된 컨테이너 파일시스템
    - 격리된 프로세스를 가진 것과 마찬가지로 각 컨테이너는 격리된 파일시스템을 갖고 있다.
    - 컨테이너 내부에서 루트 디렉터리의 내용을 조회해보면 컨테이너 안의 파일만 보여준다.

<aside>
💡 실행 중인 컨테이너에 진입하는 것은 컨테이너에 실행 중인 애플리케이션을 디버깅할 때 유용하다. 문제가 있을 때 가장 먼저 해야할 것은 애플리케이션이 보고 있는 시스템의 실제 상태를 탐색하는 것이다. 애플리케이션이 자체의 고유한 파일시스템을 보고 있을 뿐만 아니라 프로세스, 사용자, 호스트 이름, 네트워크 인터페이스도 고유한 것을 보고 있다는 사실을 명심해야 한다.
</aside>

### 2.1.7 컨테이너 중지와 삭제
- 컨테이너 중지
    - $ docker stop kubi-container
    - 컨테이너에 실행 중인 메인 프로세스를 중지시키며 컨테이너 내부에 실행 중인 다른 프로세스가 없으므로 결과적으로 컨테이너가 중지된다.
- 컨테이너 완전 삭제
    - $ docker rm kubia-container
    - 컨테이너의 모든 내용이 삭제돼 다시 시작할 수 없다.

### 2.1.8 이미지 레지스트리에 이미지 푸시
- 도커 허브, Quay.io나 구글 컨테이너 레지스트리에 푸시할 수 있다.
- 이미지를 푸시하기 전에 도커 허브의 규칙에 따라 이미지 태그를 지정해야 한다.
- 추가 태그로 이미지 태그 지정
    - $ docker tag kubia 도커ID/kubia
    - 위 명령어는 태그를 변경하지는 않아서 같은 이미지에 추가적인 태그를 생성한다.
- 도커 허브에 이미지 푸시하기
    - $ docker login 으로 로그인 후에 $ docker push luksa/kubia
- 다른 머신에서 이미지 실행하기
    - $ docker run -p 8080:8080 -d luksa/kubia
    - 호스트 머신에 Node.js 가 설치되어있더라도 이미지 내부에 설치된 것을 사용해서 리눅스 어디에서든 실행 가능하다.
    

## 2.2 쿠버네티스 클러스터 설치
- 완전한 다중 노드 쿠버네티스 클러스터 설치는 리눅스와 네트워크 관리에 능숙해야 한다.
- 올바른 쿠버네티스 설치는 여러 물리 머신 또는 가상 머신에 걸쳐 수행되며 쿠버네티스 클러스터 내에서 실행되는 모든 컨테이너가 동일한 플랫 네트워킹 공간을 통해 연결되도록 네트워크를 올바르게 설정해야 한다.
- [http://kubernetes.io](http://kubernetes.io) 참고하기!!
- 쿠버네티스는 로컬 개발 머신, 클라우드 공급자(아마존 EC2 등)에서 제공된 가상머신, 구글 쿠버네티스 엔진(GKE)나 Amazon EKS 와 같은 관리형 쿠버네티스를 사용할 수도 있다.

### 2.2.1 Minikube 를 활용한 단일 노드 쿠버네티스 클러스터 실행하기
- Minikube 는 단일 이진 파일로 다운로드한 후 실행 가능한 특정 경로(path)에 저장한다.
- [http://github.com/kubernetes/minikube](http://github.com/kubernetes/minikube) 참고해서 설치하기
- Minikube는 VirtualBox 나 KVM을 통해 실행된 가상머신 내부에 쿠버네티스를 실행하므로 Minikube 클러스터를 시작하기 전 이 가운데 하나를 설치해야 한다.
- Minikube로 쿠버네티스 클러스터 시작하기
    - $ minikube start
- 쿠버네티스 클라이언트 설치하기
    - 쿠버네티스를 다루려면 kubectl CLI 클라이언트가 필요하다. 필요한 것은 바이너리를 다운로드하고 실행 가능 경로에 두어야 한다.
    - 참고로, 여러 개의 쿠버네티스 클러스터를 사용한다면(예: Minikube와 GKE를 동시에 사용), kubectl 컨텍스트를 설정하고 다른 컨텍스트 간에 전환하는 방법을 다룬 부록 A를 참고한다.
- 클러스터 작동 여부 확인과 kubectl 로 사용하기
    - $ kubectl cluster-info
    - API 서버와 웹 콘솔(Kubernetes dashboard)을 비롯한 다양한 쿠버네티스 구성 요소의 URL을 표시한다.
    - 팁, minikube ssh 를 사용해 Minikube 가상머신에 로그인해서 내부를 살펴볼 수 있다. 노드에 실행 중인 프로세스 등을 확인 가능하다.

### 2.2.2 구글 쿠버네티스 엔진을 활용한 관리형 쿠버네티스 클러스터 사용하기
- 완전한 다중 노드 쿠버네티스 클러스터를 살펴보려면 구글 쿠버네티스 엔진(GKE 클러스터)를 사용할 수 있다. 모든 클러스터 노드와 네트워킹을 수동으로 설정할 필요가 없다.
- 구글 클라우드 프로젝트 설정과 필요한 클라이언트 바이너리 다운로드.
- 클러스터의 개념 이해하기
    - 각 노드는 도커, Kubelet, kube-proxy를 실행한다.
    - Kubectl 클라이언트 명령어는 마스터 노드에서 실행 중인 쿠버네티스 API 서버로 REST 요청을 보내 클러스터와 상호작용한다.
- 클러스터 노드를 조회해 클러스터 동작 상태 확인하기
    - 클러스터의 모든 노드를 조회한다.
        - $ kubectl get nodes
        - kubectl로 모든 종류의 쿠버네티스 오브젝트를 조회할 수 있다.
        - gcloud compute ssh <node-name> : 노드에 로그인 해서 노드에 무엇이 실행 중인지 알 수 있다.
- 오브젝트 세부 정보 가져오기
    - $ kubectl describe node gke-kubia-85f6-node-0rrx
    - 출력 결과는 CPU, 메모리, 시스템 정보, 노드에 실행 중인 컨테이너 등을 포함한 노드 상태를 보여준다.
    - kubectl describe node 는 모든 노드의 상세 정보가 출력된다.

### 2.2.3 kubectl의 alias와 명령줄 자동완성 설정하기
- 별칭 설정하기
    - ~./bashrc 와 같은 파일에 alias k=kubectl 을 추가한다.
    - gcloud는 이미 k 파일이 존재할 수도 있다.
- kubectl 의 탭 완성 설정하기
    - $ kubectl desc<TAB> no<TAB> gke-ku<TAB>
    - bash-completion 패키지 설치 후 source <(kubectl completion bash)
    - 위의 명령어는 kubectl 사용할 때만 동작한다.

## 2.3 쿠버네티스에 첫 번째 애플리케이션 실행하기
### 2.3.1 Node.js 애플리케이션 구동하기
- 가장 간단한 방법은 kubectl run 명령어로 JSON이나 YAML을 사용하지 않고 필요한 모든 구성 요소를 생성하는 방법이다.
    - $ kubectl run kubia —image=luksa/kubia —port=8080 —generator=run/v1
        - —image=luksa/kubia 는 실행하고자 하는 컨테이너 이미지 명시
        - —port=8080 옵션은 쿠버네티스에 애플리케이션이 8080포트를 수신 대기해야한다는 사실을 알려준다.
        - —generator는 보통 사용하지 않지만 쿠버네티스에서 디플로이먼트 대신 레플리케이션컨트롤러를 생성하기 때문에 사용했다. deprecated 돼서 사용법으로 run-pod/v1 또는 kubectl create를 사용하는 것이 좋다.
- 파드 소개
    - 쿠버네티스는 개별 컨테이너들을 다루지 않고, 함께 배치된 다수의 컨테이너 개념을 사용한다. 이 컨테이너 그룹을 파드라고 한다.
    - 파드는 하나 이상의 밀접하게 연관된 컨테이너의 그룹으로 같은 워커 노드에서 같은 리눅스 네임스페이스로 함께 실행된다. 각 파드는 자체 IP, 호스트 이름, 프로세스 등이 있는 논리적으로 분리된 머신이다.
    - 각 파드는 고유한 IP와 애플리케이션 프로세스를 실행하는 하나 이상의 컨테이너를 갖는다. 파드는 워커 노드에 퍼져 있다.
- 파드 조회하기
    - 컨테이너는 독립적인 쿠버네티스 오브젝트가 아니어서 개별 컨테이너를 조회할 수 없다.
    - 파드를 조회해야 한다.
    - $ kubectl get pods
    - 파드는 보류(Pending, READY 열의 0/1) 상태에서 → 이미지를 다운로드 한 후 파드의 컨테이너가 생성되고 파드의 상태가 Runnig 상태로 전환된다.
- 백그라운드에 일어난 동작 이해하기
    1. kubectl 명령어를 실행하면 쿠버네티스의 API 서버로 REST HTTP 요청을 전달한다.
    2. 클러스터에 새로운 레플리케이션컨트롤러 오브젝트를 생성한다.
    3. 레플리케이션컨트롤러는 새 파드를 생성하고 스케줄러에 의해 워커 노드 중 하나에 스케줄링이 된다.
        - 스케줄링이란? 파드가 특정 노드에 할당됨을 의미한다. 파드는 즉시 실행된다.
    4. Kubelet은 파드가 스케줄링됐다는 것을 통지 받는다. 이미지가 로컬에 없기 때문에 도커에게 레지스트리에서 특정 이미지를 풀하도록 지시한다.
    5. 이미지를 다운로드한 후 도커는 컨테이너를 생성하고 실행한다.

### 2.3.2 웹 애플리케이션에 접근하기
- 각 파드는 자체 IP 주소를 가지고 있지만 이 주소는 클러스터 내부에 있으며 외부에서 접근이 불가능하다.
- 외부에서 파드에 접근을 가능하게 하려면 서비스 오브젝트를 통해 노출해야 한다.
- 파드와 마찬가지로 일반적인 서비스(Cluster IP 등) 을 생성하면 이것은 클러스터 내부에서만 접근 가능하기 때문에 Load Balancer 유형의 특별한 서비스를 생성해야 한다.
- LoadBanacer 유형의 서비스를 생성하면 외부 로드 밸런서가 생성되므로 로드 밸런서의 퍼블릭 IP 를 통해 파드에 연결할 수 있다.
- **서비스 오브젝트 생성하기**
    - 서비스를 생성하기 위해 쿠버네티스에게 앞서 생성한 레플리케이션컨트롤러를 노출하도록 명령한다.
    - $ kubectl expose rc kubia —type=LoadBalancer —name kubia-http        
    - 팁, rc는 replicationcontroller 다. pod는 po, service는 svc로 약어를 사용한다.
- **서비스 조회하기**
    - kubectl get services 또는 kubectl get svc
    - 쿠버네티스가 실행 중인 클라우드 인프라스트럭처에서 로드 밸런서를 생성하고 가동되면 서비스 kubia-http 의 외부 IP 주소가 표시된다. EXTERNAL-IP가 보인다.
    - 팁, Minikube는 로드밸런서 서비스를 지원하지 않으므로 서비스는 외부 IP를 얻지 못한다. 하지만 외부 포트를 통해 서비스에 접근할 수 있다.
- **External IP를 이용해 서비스 접근하기**
    - 외부 IP와 포트를 통해 파드에 요청을 보낼 수 있다.
    - $ curl 104.155.74.57:8080
        - kubia-http의 EXTERNAL-IP
    - 애플리케이션에서 파드 이름을 호스트 이름으로 사용하고 있다.
        - 각 파드는 자체 IP 주소와 호스트 이름을 가진 별도의 독립 머신처럼 동작한다. 애플리케이션이 워커 노드 운영체제에서 실행 중일지라도 애플리케이션은 다른 프로세스와 함께 실행 중인 상태가 아니며 애플리케이션 전용으로 분리된 머신에서 실행 중인 것으로 나타난다.

### 2.3.3 시스템의 논리적인 부분

- 레플리케이션컨트롤러, 파드, 서비스가 서로 동작하는 방식 이해
    - kubectl run 명령을 수행하면 레플리케이션컨트롤러를 생성하고 레플리케이션컨트롤러가 실제 파드를 생성한다.
    - 클러스터 외부에서 파드에 접근케 하기 위해 쿠버네티스에게 레플리케이션컨트롤러에 의해 관리되는 모든 파드를 단일 서비스로 노출하도록 명령한다.
- 파드와 컨테이너의 이해
    - 보통 파드는 원하는 만큼의 컨테이너를 포함시킬 수 있다.
    - 컨테이너 내부에는 Node.js 프로세스가 있고 포트 8080에 바인딩돼 HTTP 요청을 기다리고 있다.
    - 파드는 자체의 고유한 사설 IP 주소와 호스트 이름을 갖는다.
- 레플리케이션컨트롤러의 역할 이해
    - 항상 정확히 하나의 파드 인스턴스를 실행하도록 지정한다.
    - 보통 레플리케이션컨트롤러는 파드를 복제(즉, 여러 개의 파드 복제)을 생성하고 항상 실행 상태로 만든다.
    - 어떤 이유로 파드가 사라진다면 레플리케이션컨트롤러는 사라진 파드를 대체하기 위해 새로운 파드를 생성할 것이다.
- 서비스가 필요한 이유 (kubia-http)
    - 파드는 일시적이어서, 언제든 사라질 수 있다. 사라진 파드는 레플리케이션컨트롤러에 의해 생성된 파드로 대체된다.
    - **새로운 파드는 다른 IP 주소를 할당받는다. 이것이 서비스가 필요한 이유다. 항상 변경되는 파드의 IP 주소 문제와 여러 개의 파드를 단일 IP와 포트의 쌍으로 노출시키는 문제를 해결한다.**
    - 서비스가 생성되면 정적 IP를 할당받고 서비스가 존속하는 동안 변경되지 않는다. 파드에 직접 연결하는 대신 클라이언트는 서비스의 IP 주소를 통해 연결해야 한다.
    - 서비스는 동일한 서비스를 제공하는 하나 이상의 파드 그룹의 정적 위치를 나타낸다.
    - 서비스의 IP와 포트로 유입된 요청은 그 순간 서비스에 속해 있는 파드 중 하나에게 전달된다.

### 2.3.4 애플리케이션 수평 확장
- 파드는 레플리케이션컨트롤러에 의해 관리된다.
- $ kubectl get replicationcontrollers    
    | NAME | DESIRED | CURRENT | AGE |
    | --- | --- | --- | --- |
    | kubia | 1 | 1 | 17m |
- kubectl get 명령은 사용 가능한 모든 오브젝트 유형의 목록을 얻을 수 있다. get, describe 등과 같은 다양한 kubectl 명령과 함께 이러한 오브젝트 유형을 사용할 수 있다.
- DISIRED 열은 레플리케이션컨트롤러가 유지해야 할 파드의 레플리카 수, CURRENT 는 현재 실행 중인 파드의 실제 수를 나타낸다.
- **의도하는 레플리카 수 늘리기**
    - $ kubectl scale rc kubia —replicas=3        
    - 쿠버네티스에 어떤 액션을 취해야 하는지만 알려줬다. 쿠버네티스의 기본 원칙 중 하나다. 쿠버네티스가 어떤 액션을 수행해야 하는지 정확히 알려주는 대신 시스템의 의도하는 상태(desired state)를 선언적으로 변경하고 쿠버네티스가 실제 현재 상태(current state)를 검사해 의도한 상태로 조정(reconcile)한다.
- **스케일아웃 결과 보기**
    - $ kubectl get rc
        | NAME | DESIRED | CURRENT | READY | AGE |
        | --- | --- | --- | --- | --- |
        | kubia | 3 | 3 | 2 | 17m |
    - $ kubectl get pods
        
        
        | NAME | READY | STATUS | RESTARTS | AGE |
        | --- | --- | --- | --- | --- |
        | kubia-hcgzi | 1/1 | Running | 0 | 17m |
        | kubia-hcgzi2 | 0/1 | Pending | 0 | 7s |
        | kubia-hcgzi3 | 1/1 | Running | 0 | 18m |
- **서비스 호출 시 모든 파드가 요청을 받는지 확인**
    - 서비스 URL을 호출했을 때 어떤일이 일어나나?
    - $ curl 104.155.74.57:8080 여러번 호출 시 무작위로 다른 파드를 호출하고 있다.
    - 서비스는 다수 파드 앞에서 로드밸런서 역할을 한다. 파드가 하나만 있으면 서비스는 이 파드 하나에 정적 주소를 제공한다. 서비스를 지원하는 파드가 하나든지 파드 그룹이든지에 관계없이 해당 파드가 클러스터 내에서 이동하면서 생성되고 삭제되며 IP가 변경되지만, 서비스는 항상 동일한 주소를 가진다.
- **시스템의 새로운 상태 시각화**
    - 책 그림 참고하기

### 2.3.5 애플리케이션이 실행 중인 노드 검사하기
- 어떤 노드에 파드가 스케줄링됐는지 궁금할 수 있는데, 쿠버네티스에서는 파드가 스케줄링된 노드와 상관없이 컨테이너 내부에 실행 중인 모든 애플리케이션은 동일한 유형의 운영체제 환경을 갖는다. 각 파드는 자체 IP를 가지고 다른 파드가 같은 노드에 있는지 혹은 다른 노드에서 실행 중인지 상관없이 통신 할 수 있다. 각 파드는 요청된 만큼의 컴퓨팅 리소스를 제공받는다.
- **파드를 조회할 때 파드 IP와 실행 중인 노드 표시하기**
    - 기본 kubectl get pods 명령에서는 파드가 스케줄링된 노드에 대한 정보가 보이지 않는다.
    - $ kubectl get pods -o wide 옵션을 주면 파드 IP와 파드가 실행 중인 노드를 표시한다.
- **kubectl describe 로 파드 세부 정보 살펴보기**
    - $ kubectl describe pod kubia-hczji
    - 노드 정보, 실행된 시간, 실행 중인 이미지 등과 같은 정보를 나타낸다.
        

### 2.3.6 쿠버네티스 대시보드 소개
- 대시보드에서 파드, 레플리케이션컨트롤러, 서비스 같은 클러스터의 많은 오브젝트를 조회할 수 있고 생성, 수정, 삭제 또한 가능하다.
- **GKE에서 쿠버네티스를 사용할 때 대시보드 접근하기**
    - GKE를 사용하는 경우 kubectl cluster-info 명령으로 대시보드 URL을 찾을 수 있다.
    - $ kubectl cluster-info | grep dashboard
    - 아래 명령어로 대시보드의 사용자 이름과 패스워드를 알 수 있다.
        - $ gcloud container clusters describe kubia | grep -E “(username|password):"
- **Minikube를 사용할 때 대시보드 접근하기**
    - minikube dashboard

## 2.4 요약
- 공개된 컨테이너 이미지를 풀하고 실행할 수 있다.
- 애플리케이션을 컨테이너 이미지로 패키징하고 원격 이미지 레지스트리에 이미지를 푸시해 누구나 사용할 수 있게 한다.
- 실행 중인 컨테이너에 접속해 환경을 확인할 수 있다.
- GKE에 다중 노드 쿠버네티스 클러스터를 설정할 수 있다.
- 쿠버네티스 클러스터의 노드, 파드, 서비스, 레플리케이션컨트롤러를 조회하고 검사할 수 있다.
- 쿠버네티스에 컨테이너를 실행하고 클러스터 외부에서 접근 가능하게 할 수 있다.
- 파드, 레플리케이션컨트롤러, 서비스가 어떻게 연관돼 있는지 기본 개념을 이해할 수 있다.
- 레플리케이션컨트롤러의 레플리카 수를 변경해 애플리케이션을 수평으로 확장할 수 있다.
- Minikube나 GKE의 웹 기반 쿠버네티스 대시보드에 접근할 수 있다.
