### JUnit 단언 비교
- 두 가지 방식을 섞어 쓰기보단, 한 가지 방식으로 사용하는 것이 좋다.
- JUnit 에 포함된 단언
  - assertTrue 등
  - fail일 경우 stack trace를 통해 비교값을 알기 어렵다.
- 햄크레스트
  - assertThat 등
  - stack trace에 문제를 해결하는데 필요한 정보를 담고 있어서 확인하기 좋다.
- 햄크레스트 매처 살펴보기
  - CoreMatchers 클래스는 매처 모음을 제공
  - 자바 배열 혹은 컬랙션 객체 비교할 때
    - assertThat(new String[] {"a", "b", "c"}, equalTo(new String[] {"a", "b"}));
  - is 로 매처 표현의 가독성을 높일 수도 있음
    - 넘겨받은 매처를 반환하고 아무것도 하지 않음. 가독성을 위해 사용.
    - assertThat(new String[] {"a", "b", "c"}, is(equalTo(new String[] {"a", "b"})));
  - not
    - assertThat(new String[] {"a", "b", "c"}, not(equalTo(new String[] {"a", "b"})));
  - null 검사
    - assertThat(account.getName(), is(not(nullValue())));
    - null 이 아님을 자주 검사하는 것은 설계 문제이거나 지나치게 걱정하는 것. 많은 경우 불필요.
- 햄크레스트 API 문서 확인해보기
  - 사용자 정의 매처도 만들수 있음 (구글의 튜토리얼에 만드는 방법 나옴)
  - isCloseTo
  - 부동소수점 비교

- 예외 테스트 방법
```java
@Test(expected=InvalidException.class)
try {
  ~;
  fail();
} catch (e: Exception) {
  assertThat(,)
}
```
- ExpectedException 규칙
  - @Rule ExpectedException 추가
  - JUnit Rule 은 AOP 와 유사한 기능을 제공한다.
  - 자동으로 테스트 집합에 대한 종단 관심사를 부착할 수 있다.
  - https://github.com/gilbutITbook/006814/blob/master/iloveyouboss_13/test/scratch/AssertTest.java
  - Fishbowl 등
  - 예외 무시
  - checked exception 처리는 예외가 발생하지 않는다면 throws 하는 것을 추천


# 4장 테스트 조직
- 내부 데이터 노출 VS 내부 동작 노출
  - 테스트를 위해 내부 데이터를 노출하면 테스트와 프로덕션 코드 사이에 과도한 결합을 초래한다.
  - 내부 동작(private)을 테스트하고 싶다면, 설계에 문제가 있는 것이다. 자바 리플렉션으로도 접근 권한을 우회할 수 있지만 하지 않는 것이 좋다.
  - 거의 단일 책임 원칙을 어겼을 것이다.
- 집중적인 단일 목적 테스트의 가치
  - 다수의 케이스를 별도의 JUnit 테스트 메서드로 분리하고, 각각에는 검증하는 동작을 표현하는 이름을 붙이는 것을 추천한다.
- **일관성 있는 이름으로 테스트 문서화**
  - 예시
    - makeSingleWithdrawal -> withdrawalReducesBalaneByWithdrawalAmount
    - attemptToWithdrwalTooMuch -> withdrawalOfMoreThanAvailableFundsGeneraterError
    - multipleDeposits -> multipleDepositsIncreaseBalanceBySumOfDeposits
  - 합리적인 테스트 이름은 단어 일곱개 정도로 구성되어 있을 것이다.
  - 추천하는 양식
    - doingSomeOperationGeneratesSomeResult
      - 어떤 행동을 하면 어떤 결과가 나온다
    - **someResultOccursUnderSomeCondition**
      - 어떤 결과는 어떤 조건에서 발생한다
    - givenSomeContextWhenDoingSomeBehaviorThenSomeResultOccurs
      - 주어진 조건에서 어떤 일을 하면 어떤 결과가 나온다
      - given-when-then과 같은 양식
      - JDave, easyb 같은 테스트 프레임워크가 긴 이름을 잘 지원하기는 하지만 길 수도 있어서, givenSomeContext 부분은 제거할 수도 있다.
    - whenDoingSomeBehaviorThenSomeResultOccurs
      - 어떤 일을 하면 어떤 결과가 나온다
  - 어떤 형식이든 일관성을 유지하는 것이 중요하다.
- **테스트를 의미있게 만들기 : 파악이 어려운 테스트 코드는 테스트 이름을 개선해야 하고, 아래 사항도 고려해야 한다.**
  - 지역 변수 이름 개선하기
  - 의미 있는 상수 도입하기
  - 햄크레스트 단언 사용하기
  - 커다란 테스트를 작게 나누어 집중적인 테스트 만들기
  - 테스트 군더더기들을 도우미 메서드와 @Before 메서드로 이동하기
- **@Before와 @After**
  - 이전 장에서 여러 테스트에 있는 중복 초기화 코드를 @Before로 이동했었다.
  - 테스트를 추가하게 되면 상당한 코드가 같은 초기화 부분을 가진다는 것을 발견할 수 있는데, @Before 메서드를 활용하자.
  - 단일 @Before 를 여러 개로 분할하는 방법도 생각하자.
    - @Before createAccount
    - @Before resetAccountLogs
    - @Test depositIncreasesBalance
  - 순서가 필요하다면 단일 @Before 메서드로 결합하여 순서대로 실행되도록 해야 한다.
  - @After 는 클래스에 있는 각 테스트를 한 후 실행되며, 테스트가 실패하더라도 실행된다.
- @BeforeClass와 @AfterClass
  - 클래스에 있는 어떤 테스트를 실행하기 전 한 번만 실행된다.
- 녹색 테스트를 유지하기
  - 실패하는 테스트는 늘리지 말고, 실패하면 곧바로 고치는 것이 좋다.
  - 필요한 테스트만 실행하기보다 전체 테스트를 수행하는 것이 좋다.
  - 테스트를 빠르게 하는 방법
    - 목 객체 활용하기
    - 패키지별로 실행하기
    - Infinitest 처럼 백그라운드에서 테스트를 항상 실행하는 도구를 고려
    - Junit의 Categories 기능으로 특정 카테고리에 해당하는 테스트만 별도로 실행
      - https://junit.org/junit5/docs/current/user-guide/#running-tests-tags
      - https://docs.gradle.org/current/userguide/java_testing.html
    - 통합 테스트 플러그인?
      - https://docs.gradle.org/current/userguide/testing_gradle_plugins.html
- 대부분의 단위 테스트는 빨라야 한다
- 견딜 수 있는 만큼 많은 테스트를 실행하세요.
- @Ignore로 잠시 제외할 수도 있다.



# 5장 FIRST
- [F]IRST : 빨라야 한다.
  - 테스트 코드는 동시에 실행할 수도 있다는 점을 잊지말아야 한다.
  - 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않는다. 생성된 데이터를 재사용해서 속도를 높이려는 방식은 악순환될 수 있다.
  - 두 번째 단언(assert)를 추가할 때 스스로 질문하자.
  - 단언이 단일 동작을 검증하도록 돕는가, 아니면 내가 새로운 테스트 이름으로 기술할 수 있는 어떤 동작을 대표하는가?
- F[I]RST : 고립시킨다.
  - SRP는 테스트 메서드에도 훌륭한 지침을 제공한다. 테스트 메서드가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려하자.
- FI[R]ST : 좋은 테스트는 반복 가능해야 한다.
- FIR[S]T : 스스로 검증 가능하다.
- FIRS[T] : 적시에 사용한다.
- 테스트를 실행하는데 외부 설정이 필요하다면 고립성을 위반한 것이다.
- 시스템이 변경되면 Infinitest는 이들을 식별하고 백그라운드로 잠재적으로 영향을 받는 테스트들을 실행한다.
- 테스트는 통문(gating) 조건이 된다.
- 소스 코드는 컴파일되지 않으면 그것을 해결할 때까지 다음으로 진행하지 않는다.
- 젠킨스 또는 TeamCity 같은 지속적 통합을 사용할 수도 있다.
- 소스 저장소를 관찰하여 변화를 감지하면 빌드와 테스트 절차를 시작한다.
- **옛날 코드에 대한 테스트는 시간 낭비가 될 수도 있다. 큰 결함이 없고, 변경할 예정이 없다면 노력을 좀 더 말썽이 많고 역동적인 부분에 사용해도 된다.**



# 6장 [Right]-BICEP
- 무엇을 테스트할지?
  - Right : 결과가 올바른가?
  - B : 경계 조건(boundary conditions)은 맞는가?
  - I : 역 관계(inverse relationship)을 검사할 수 있는가?
  - C : 다른 수단을 활용하여 교차 검사(cross-check)할 수 있는가?
  - E : 오류 조건(error conditions)을 강제로 일어나게 할 수 있는가?
  - P : 성능 조건(performance characteristics)은 기준에 부합하는가?
- 클래스가 외부에서 호출하는 API이고 클라이언트를 완전히 믿을 수 없다면 나쁜 데이터에 대한 보호가 필요하다. 하지만 클라이언트가 팀 소속이라면 보호절들을 제거하고 클라이언트에게 알려도 된다. 보호절을 제거한다면 주석으로 경고하거나, 더 좋은 방법인 코드 제한 사항을 문서화하는 테스트를 추가하는 것이다.
- Right-BICEP
  - Right-B[I]CEP : 역 관계를 검사할 수  있는가?
    - 곱셉으로 나눗셈을 검증하고, 뺄셈으로 덧셈을 검증하는 것처럼 말이다.
  - Right-BI[C]EP : 다른 수단을 활용하여 교차 검사할 수 있는가?
    - 문제에는 여러 해법이 존재하는데 1등 해법이 아닌 패배자 해법을 교차 검사할 때 활용할 수 있다.
  - Right-BICE[P]
    - 성능을 측정할 때는 충분한 개수를 반복해야 결과 수치가 튀지 않는다.
    - **최적화 전 기준점으로 단지 현재 경과 시간을 측정하는 성능 테스트를 작성하고, 몇 번 실행해보고, 평균을 계산해야 한다.**
    - 모든 성능 최적화 시도는 실제 데이터로 해야 하며 추측을 기반으로 해서는 안된다.
    - JMeter, JUnitPerf



# 7장 경계 조건: CORRECT 기억법
- 테스트를 만들 때 고려해야할 경계 조건들이다.
  - [C]onformance(준수) : 값이 기대한 양식을 준수하고 있는가?
  - [O]rdering(순서) : 값의 집합이 적절하게 정렬되거나 정렬되지 않았나?
  - [R]ange(범위) : 이성적인 최솟값과 최댓값 안에 있는가?
  - [R]eference(참조) : 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
  - [E]xistence(존재) : 값이 존재하는가(널이 아니거나, 0이 아니거나, 집합에 존재하는가 등)?
  - [C]ardinality(기수) : 정확히 충분한 값들이 있는가?
  - [T]ime(절대적 혹은 상대적 시간) : 모든 것이 순서대로 일어나는가? 정확한 시간에? 정시에?
- **잘못될 수 있는 것이 떠오르면 테스트 이름을 적어 놓고, 시간이 있을 때 테스트에 살을 붙이세요.**
- [C]OREECT : [C]onformance(준수)
  - 구조적 데이터의 경우 테스트 케이스를 조합하면 많은 결함을 발견할 수 있다.
  - 그럼 언제 테스트 작성을 중단?
    - 필드가 처음 입력될 때 검증한다면 그 필드를 인자로 넘길 때마다 검사하지 않아도 된다. 시스템의 데이터 흐름을 이해한다면 불필요한 검사를 최소화할 수 있다.



# 11장 테스트 리팩토링
- **테스트 냄새: 불필요한 테스트 코드**
  - 테스트 코드에서 예외가 발생하지 않을 예정이라면 throws 해도 된다. (checked exception)
  - 불필요한 not-null 단언은 제거한다.
- **테스트 냄새: 추상화 누락**
  - 단일 개념을 구현하는 테스트 단언이 2줄 혹은 3줄이라면 깔끔한 문장 1줄로 추출할 수 있는지 고민해본다. 예로 사용자 정의 매처를 사용한다.
- **테스트 냄새: 부적절한 정보**
  - 테스트코드를 이해하는데 불필요한 리터럴은 상수로(ANY_~, ARBITRARY_~) 분리하거나 빈문자열을 사용해서 신경쓰지 않는 데이터를 표현해도 된다.
- **테스트 냄새: 부푼 생성**
  - given 절을 생성할 때 세부 사항은 메서드로 추출할 수도 있다.
- **테스트 냄새: 다수의 단언**
  - 여러 개의 단언이 있다는 것은 테스트케이스를 두 개 포함하고 있을 수 있다. 나누면 테스트 메서드 이름을 깔끔하게 만들기 쉽다.
- **테스트 냄새: 테스트와 무관한 세부 사항들**
  - 로그를 끄는 작업이나 stream.close()와 같은 세부사항은 @Before, @After로 이동한다. 이때 테스트를 이해하는 데 필요한 정보도 이동했는지 주의해야 한다.
  - 좋은 테스트는 독자가 테스트를 이해하는데 다른 함수를 파헤치지 않도록 한다.
- **테스트 냄새: 잘못된 조직**
  - 테스트에서 준비, 실행, 단언 부분(given, when, then)이 어디인지 알 수 있게 하는 것은 테스트를 빠르게 인지할 수 있게 한다.
- **테스트 냄새: 암시적 의미**
  - 독자는 테스트 준비와 단언 부분을 상호 연관 지을 수 있어야 한다. 좀 더 나은 테스트 데이터로 변경하면 이해하기 쉽다.
  - 상호 관련성을 향상시키는 방법은 다양하다. 의미 있는 상수, 더 좋은 변수 이름, 더 좋은 데이터와 때때로 테스트에서 계산을 적게만드는 것이 도움이 된다. 창의력을 발휘해보세요!



# 12장 테스트 주도 개발
- TDD 사이클
  - 실패하는 테스트 코드 작성하기
  - 테스트 통과시키기
  - 이전 두 단계에서 추가되거나 변경된 코드 개선하기
  - 또 다른 증분 추가
  - 테스트 케이스를 작게 하나씩 추가한다.
  - 테스트 코드 추가에 맞춰 코드를 개선한다.
  - 테스트 정리
    - @Before 메서드에 공통 초기화를 넣는다.
  - 또 다른 증분 추가
  - 테스트 케이스를 하나 더 추가한다. TDD의 일부는 작성할 필요가 있는 테스트를 추가하고, 각 테스트를 통과하게 만드는 코드 추가를 최소화하는 순으로 진행하는 것이다.
- 다수의 응답 지원: 작은 설계 우회로
  - TDD를 할 때 필요하다면 설계를 변경할 수도 있다.
  - 인터페이스 확장
- 문서로서의 테스트
  - 세심하게 테스트를 작성할수록 테스트는 Profile 클래스에 의도적으로 설계된 동작들을 더 많이 문서화할 수 있다.
  - 테스트하고자 하는 객체의 이름은 제거할 수도 있다.
    - 예로 Profile 객체들을 테스트한다면 matchesWhenContainesMultipleAnswers
  - 꼭 한 클래스에 모두 넣을 필요는 없다. 각 테스트 클래스 혹은 고정물(fixture)로 나누면 연관된 동작 그룹에 집중할 수 있다.
    - class Profile_MathcesCriterionTest {}
    - class Profile_MatchesCriteriaTest {}
    - class Profile_ScoreTest {}
  - 테스트하려는 동작을 테스트 클래스의 이름으로 넣으면 개별 테스트 이름에서 중복되는 정보를 제거할 수 있다.
- TDD의 리듬
  - TDD의 사이클은 짧다. 테스트-코드-리팩토링의 각 사이클은 몇 분이면 된다.
  - 10분 정도 사이에 테스트 통과를 만들지 못했다면 다시 좀 더 작은 단계로 조절하는 것이 좋다.
  - 각 TDD 사이클은 테스트를 가설로 한 시간 제한이 있는 실험으로 취급하고, 실험이 실패했을 땐 범위를 축소하면 도움이 될 것이다.



# 13장 까다로운 테스트
- 멀티스레드 코드 테스트
  - 동시성 처리가 필요한 애플리케이션 코드를 테스트하는 것은 통합 테스트로 분리하는 것이 낫다.
  - 멀티스레드 코드를 테스트할 때
    - 스레드 통제와 애플리케이션 코드 사이의 중첩을 최소화한다 : 스레드 없이 다량의 애플리케이션 코드를 단위 테스트할 수 있도록 설계를 변경한다. 남은 작은 코드에 대해 스레드에 집중적인 테스트를 작성한다.
    - 다른 사람의 작업을 믿는다 : java.util.concurrent 는 오랜시간 충분히 검증받았다. 예를 들어 생산자(producer)/소비자(consumer) 문제를 직접 코딩하지 말고 유용성을 입증한 BlockingQueue 클래스를 사용한다.
  - 테스트 예제
    - 애플리케이션 로직과 스레드 로직을 작게 분리한다.
    - 스레드 로직에서 비동기 호출은 mock, verify를 이용하고, verify를 이용할 때 기대한 인수를 넘긴다.
    - 스레드 테스트를 위해 process 로직은 잘 동작한다고 가정하고, 재설계하여 테스트한다. 이전코드와 재설계, 테스트코드 참고 필요.
      - https://github.com/gilbutITbook/006814/blob/master/iloveyouboss_thread-3/src/iloveyouboss/ProfileMatcher.java
      - https://github.com/gilbutITbook/006814/blob/master/iloveyouboss_thread-4/src/iloveyouboss/ProfileMatcher.java
      - https://github.com/gilbutITbook/006814/blob/master/iloveyouboss_thread-4/test/iloveyouboss/ProfileMatcherTest.java
- 데이터베이스 테스트
  - 진짜 데이터베이스와 상호 작용하는 테스트를 작성한다. 영속적인 모든 상호 작용을 시스템의 한곳으로 고립시킬 수 있다면 통합 테스트의 대상은 줄어들 것이다.
  - 테스트 목적으로 H2 같은 인메모리 사용은 속도는 빠르겠지만 운도 필요하다.
  - 테스트 안에서 데이터를 생성하고 관리해야 한다. 테스트 간 데이터 의존성이 있다면 테스트가 망가질 수 있다.
  - 데이터베이스가 트랜잭션을 지원한다면 테스트마다 트랜잭션을 초기화하고, 테스트가 끝나면 롤백하는 것도 방법이다.
  - 통합 테스트는 작성과 유지 보수가 어렵다. 자주 망가지고, 디버깅도 오래 걸리지만 테스트 전략의 필수적인 부분이다. 그래서 단위 테스트에서 검증하는 로직을 최대화하는 방향으로 통합 테스트 개수와 복잡도를 최소화하는 것을 추천한다.
- 마치며
  - 어려운 시나리오들에 대해 아래 전략을 추천한다.
  - 관심사를 분리하세요. 애플리케이션 로직은 스레드, 데이터베이스 혹은 문제를 일으킬 수 있는 다른 의존성과 분리하세요. 의존적인 코드는 고립시켜서 코드 베이스에 만연하지 않도록 하세요.
  - 느리거나 휘발적인 코드를 목으로 대체하여 단위 테스트의 의존성을 끊으세요.
  - 필요한 경우에는 통합 테스트를 작성하되, 단순하고 집중적으로 만드세요.



# 14장 프로젝트에서 테스트
- 팀과 같은 편 되기
  - 단위 테스트는 개인별로 생각하는 바가 매우 다르다. TDD, 필요하다고 느낀 테스트에서만 단위 테스트, 다수의 케이스를 단일 테스트 메서드로 몰아넣기, 느린 통합 테스트 선호 등.
  - 어떤 것에는 동의하고 합의점을 늘려 가는 방향으로 시작해야 한다.
- 단위 테스트 표준 만들기
  - 아래 두 질문에 대답해 보세요.
    - 개발자들은 어떤 것이 모든 사람의 시간을 많이 낭비하게 만든다고 느끼나요?
    - 모두가 빠르게 동의할 수 있는 단순한 표준은 무엇인가요?
  - 표준은 필요할 때마다 살피고 수정해야 한다. 적어도 분기별로는 표준들을 살피고 고쳐야 한다. 초창기에는 더욱 그렇다.
  - 초창기에 표준화해야 하는 목록
    - 코드를 체크인하기 전에 어떤 테스트를 실행해야 할지 여부
    - 테스트 클래스와 메서드의 이름 짓는 방식
    - 햄크레스트 혹은 전통적인 단언 사용 여부
    - AAA 사용 여부 (given-when-then과 같은)
    - 선호하는 목 도구 선택
    - 체크인 테스트를 실행할 때 콘솔에 출력을 허용할지 여부
    - 단위 테스트 스위트에서 느린 테스트를 분명하게 식별하고 띄울 방법
- 리뷰로 표준 준수 높이기
  - 표준을 준수하는 것은 쉽지 않다.
  - 단위 테스트 작성자가 피드백 요청 또는 페이건 검사(Fagan inspections) 같은 기법으로 리뷰 절차를 공식화하거나 PR을 활용할 수도 있다.
- 짝 프로그래밍을 이용한 리뷰
  - 논란이 많았다. 짝 프로그래밍 옹호자는 그것이 적극적인 형태의 리뷰라고 주장한다.
  - 사후 리뷰에서 보통 리뷰어들이 세부 내용에 익숙하지 않기 때문에 최상의 리뷰는 코드를 깊이 이해한 사람에게서 나온다. 그래서 보통 더 적은 결함을 찾게 되며, 보통 표면 수준의 결함을 찾게 된다. 가치는 있지만 들이는 노력만큼 그 가치가 높지는 않다.
  - 짝 프로그래밍을 성공적으로 수행하기 위해선 노하우가 필요하다. PragPub '짝 프로그래밍의 이익', '짝 프로그래밍 빠르게 시작하기'에 그라운드 룰과 피해야 할 몇 가지 위험들이 있다.
- 지속적 통합으로 수렴
  - CI는 코드를 더 자주 통합하고 그 결과를 매번 검증하는 것을 의미한다. 코드를 변경점과 합쳤을 때 동작하지 않는다는 것을 빨리 알수록 팀 성과는 좋아진다.
  - CI 서버는 소스 저장소를 모니터링한다. 새로운 코드가 체크인되면 CI 서버는 소스 저장소에서 코드를 가져와 빌드를 초기화하고, 빌드에 문제가 있다면 CI 서버는 개발 팀에 통지한다.
  - CI 서버가 어떤 가치를 제공하려면 빌드가 단위 테스트를 함께 수행해야 한다.
  - CI 서버는 허드슨(Hudson), 젠킨스(Jenkins)(허드슨의 후손), 팀시티(TeamCity), AndHill, CruiseControl, Buildbot, Bamboo 등이 있다.
- 코드 커버리지
  - Emma, Cobertura 등이 있다.
  - 대부분의 사람은 70% 이하의 커버리지는 불충분하다고 말한다.
  - 저자 중 한명은 낮은 커버리지의 영역에서 나쁜 코드의 양도 증가한다고 말한다.
  - 일반적으로 TDD를 수행하는 개발자들은 정의상 90%를 초과 달성한다.
  - 테스트 작성을 완료했다고 생각할 때 커버리지 도구를 실행한다. 커버하지 않은 코드 영역을 염려한다면 더 많은 테스트를 작성한다.
  - 코드 커버리지 숫자는 그 자체로 큰 의미가 없다. 하지만 추세는 중요하다. 팀은 시간이 지나면서 커버리지 퍼센트가 높아져야 하고 아래 방향을 내려가면 안된다.
  - Tip, 코드 커버리지 도구는 코드가 어디에서 커버리지가 부족한지, 팀이 어디에서 아래 방향으로 내려가고 있는지 이해하려고 할 때만 사용한다.
