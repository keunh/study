- sealed
    - 상위 클래스에 sealed 변경자를 사용하면 이를 상속한 하위 클래스는 반드시 상위 클래스 안에 중첩시켜야 한다.
    - 상위클래스를 받는 함수가 있을 때 그 함수에서 when을 쓴다면 자동으로 모든 하위 클래스를 검사해준다.
    - sealed는 자동으로 open 이다.
- 클래스
    - 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다.
- 인터페이스
    - 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수 있다. 물론 그런 게터와 세터는 뒷받침하는 필드를 참조할 수 없다.
- **클래스 위임 - by 키워드 사용**
    - 대규모 객체지향 시스템 설계시 시스템의 취약점은 대부분 구현 상속에 의해 발생한다.
    - 하위클래스가 상위 클래스 메소드의 일부를 오버라이드 하면 하위 클래스는 상위 클래스의 세부 구현 사항에 의존하게 된다.
    - 코틀린은 기본적으로 클래스를 final 로 하고 open 변경자로 열어둔 클래스만 확장이 가능하다.
    - **상속을 허용하지 않는 클래스에 새로운 동작이 필요한경우 데코레이터 패턴을 사용한다.**
    - 데코레이터의 단점은 위임을 위한 준비 코드가 필요한다는 것이다.
    - 이런 위임을 언어가 제공하는 일급 시민 기능으로 지원한다는 것이 코틀린의 장점이다.
- **object 키워드 - 클래스 선언과 인스턴스 생성**
    - 코틀린에서 object 키워드를 다양한 상황에서 사용하지만 모든 경우 클래스 정의와 동시에 인스턴스를 생성한다.
    - 객체 선언 (object declaration) 은 싱글턴을 정의하는 방법중 하나
        - object class 로 선언
            - 일반 객체(클래스 인스턴스)를 사용할 수 있는 곳에서는 항상 싱글턴 객체를 사용할 수 있다.
        - class Person() {  object NameComparator: Comp~ {} }
    - 동반 객체 (companion object) 는 클래스와 관련된 메소드와 팩토리 메소드를 담을 때 쓰인다.
        - classA { compainon object {} }
        - 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다.
        - 동반 객체에도 이름을 붙일 수 있다. 없으면 Companion이 된다.
    - object 를 무명 객체로도 쓸 수 있다.
        - window.addMouseListener { object : MouseAdapter() {}}
        - 무명 객체는 싱글턴이 아니다.
    - 객체 식은 자바의 익명 내부 클래스 대신 쓰인다.
- 정리
    - 코틀린의 인터페이스는 자바 인터페이스와 비슷하지만 디폴트 구현을 포함할 수 있고(자바 8부터는 자바도 가능), 프로퍼티도 포함할 수 있다(자바는 불가능)
    - 모든 코틀린 선언은 기본적으로 final이며 public이다.
    - 선언이 final이 되지 않게 만들려면(상속과 오버라이딩이 가능하게 하려면) 앞에 open을 붙여야 한다.
    - internal 선언은 같은 모듈 안에서만 볼 수 있다.
    - 중첩 클래스는 기본적으로 내부 클래스가 아니다. 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키려면 inner 키워드를 중첩 클래스 선언 앞에 붙여서 내부 클래스로 만들어야 한다.
    - sealed 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩(또는 내부) 클래스로 정의해야 한다(코틀린 1.1부터는 같은 파일 안에만 있으면 된다).
    - 초기화 블록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있다.
    - field 식별자를 통해 프로퍼티 접근자(게터와 세터) 안에서 프로퍼티의 데이터를 저장하는데 쓰이는 뒷받침하는 필드를 참조할 수 있다.
    - 데이터 클래스를 사용하면 컴파일러가 equals, hashCode, toString, copy 등의 메소드를 자동으로 생성해준다.
    - 클래스 위임을 사용하면 위임 패턴을 구현할 때 필요한 수많은 성가신 준비 코드를 줄일 수 있다.
    - 객체 선언을 사용하면 코틀린답게 싱글턴 클래스를 정의할 수 있다.
    - (패키지 수준 함수와 프로퍼티 및 동반 객체와 더불어) 동반 객체는 자바의 정적 메소드와 필드 정의를 대신한다.
    - 동반 객체도 다른 (싱글턴) 객체와 마찬가지로 인터페이스를 구현할 수 있다. 외부에서 동반 객체에 대한 확장 함수와 프로퍼티를 정의할 수 있다.
    - 코틀린의 객체 식은 자바의 무명 내부 클래스를 대신한다. 하지만 코틀린 객체 식은 여러 인스턴스를 구현하거나 객체가 포함된 영역에 있는 변수의 값을 변경할 수 있는 등 자바 무명 내부 클래스보다 더 많은 기능을 제공한다.
